\chapter{Background and Theory}
%This chapter should describe the theoretical background needed to understand and solve the problem. 
%For instance, a description of the hardware platform or specific components involved in this assignment, definition of concepts that are important to understand the solution should be summarized here.
%Add citations to show sources whenever appropriate, LaTeX and bibliography managers make this easy. For instance, ``I always thought something was fundamentally wrong with the universe'' \cite{adams1995hitchhiker}.

For the exercise, an EFM32GG-DK3750 development kit from Silicon Labs was used. It features an ARM Cortex-M3 CPU core, multiple IO capabilities, and an energy monitoring system. The development kit has a large focus on energy efficiency, and all individual components are turned off by default, meaning they must be enabled in order to be used. A gamepad peripheral which consists of 8 pushable buttons and 8 LED lights was used for input and output purposes. 

\section{GPIO}
The EFM32GG development board has five GPIO ports ranging from A to E, where each port has 16 pins. The GPIO pins can be confgured in many ways including input with filter and output with different drive strength. The usage of filter on input will eliminate any bouncing effect when a button is pressed, meaning that the CPU will not pick up several edge changes when a button is pressed. Setting the drive strength to an output current that just fits the requirement of the device connected will make the development board more energy efficient. In many cases it is possible to set the drive strength lower than the optimal setting and still have the device performing just as well. This can for example be done on LEDs.

\section{Interrupts}
The development board supports the use of interrupts. Interrupts will make the CPU halt the code currently being executed and jump to an interrupt routine. After the interrupt routine is done, the CPU will return to what it was doing. Interrupts can be used in lots of applications, for example when a button is pressed, when the DMA is done with a task or at a continuous interval by a timer. The alternative way of doing it is having the CPU check the status regularly. This is called polling. It requires the CPU to constantly check the modules so that it doesn't miss out on some information. Because of this, the CPU can't go into sleep. And it is therefore much more energy efficient to have interrupts call the CPU instead of having the CPU poll the devices.

\section{DAC}
The DAC, Digital to Analog Converter, is a module that will generate a voltage depending on the digital input it is given. A DAC is mainly used to generate sound signal. The DAC on the development board uses a 12 bit input. This means it can have 4096 different levels of output voltage. The maximum output voltage can be set to 1.25 V, 2.5 V or another voltage source. The output voltage will be $max\ voltage * \frac{input}{4096}$. This means the DAC will output a voltage between 0 V and maximum voltage. 

In order to use the DAC to generate sound waves one must configure it to run on a specific clock frequency and then feed it with input on every clock cycle. The input data must be samples of a wave. This wave can be square wave, sine wave, sawtooth wave, or any waves really. The main thing to consider is the frequency of the wave. When a sample rate is chosen (sample rate is the rate of the clock running the DAC), the amount of samples per wave period is calculated by $amount\ of\ samples = \frac{sample rate}{desired frequency}$. Using this one can generate different samples for the sound frequency needed, and then feed the different samples into the DAC to generate a sound wave on the desired frequency.

\section{Timers}
Timers are modules uses a clock or some other input as source to count to a defined value before sending an interrupt to the CPU. By having a clock as source, the timer can very accurately send interrupts to the CPU on a regular interval. This is useful when keeping track of time or when some operations are required to be performed regularly. The way a timer works is that it either counts up or down from a start value till it reaches a set compare value or overflow/underflow. It will then reset the counter and fire a interrupt. If it is desired to have an interrupt every clock cycle, then one can for example set the timer to count down, and start at 1. 

% fra rapport 1:
%  -background: needs more content. organize into subsections and add more content on the relevant background topics (some examples: a general overview of polling vs interrupts and their energy efficiency implications, EFM32s energy modes, relevant figures/tables/etc from manuals with references)